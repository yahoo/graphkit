######################
Plotting and Debugging
######################

.. _plotting:

Plotting
--------

For :ref:`debugging` it is necessary to visualize the graph-operation.
You may plot the original plot and annotate on top the *execution plan* and
solution of the last computation, calling methods with arguments like this::

   graphop.plot(show=True)                # open a matplotlib window
   graphop.plot("intro.svg")              # other supported formats: png, jpg, pdf, ...
   graphop.plot()                         # without arguments return a pydot.DOT object
   graphop.plot(solution=out)             # annotate graph with solution values

.. image:: images/intro.svg
    :alt: Intro graph

.. figure:: images/GraphkitLegend.svg
   :alt:  Graphkit Legend

   The legend for all graphkit diagrams, generated by :func:`graphkit.plot.legend()`.

The same ``plot()`` methods are defined on a :class:`NetworkOperation`,
:class:`Network` & :class:`ExecutionPlan`, each one capable to produce diagrams
with increasing complexity.  Whenever possible, the top-level ``plot()`` methods
delegates to the ones below.

For instance, when a net-operation has just been composed, plotting it will
come out bare bone, with just the 2 types of nodes (data & operations), their
dependencies, and the sequence of the execution-plan.

But as soon as you run it, the net plot calls will print more of the internals.
These are based on the ``graph_op.net.last_plan`` attribute which *caches*
the last run to inspect it.  If you want the bare-bone diagram, simply reset it::

   netop.net.last_plan = None

.. Note::
   For plots, `Graphviz <https://graphviz.org>`_ program must be in your PATH,
   and ``pydot`` & ``matplotlib`` python packages installed.
   You may install both when installing ``graphkit`` with its ``plot`` extras::

      pip install graphkit[plot]

.. Tip::
   The `pydot.Dot <https://pypi.org/project/pydot/>`_ instances returned by ``plot()``
   are rendered directly in *Jupyter/IPython* notebooks as SVG images.


.. _debugging:

Errors & debugging
------------------

If an operation fails, the original exception gets annotated
with the folllowing properties, as a debug aid:

>>> from pprint import pprint

>>> def scream(*args):
...     raise ValueError("Wrong!")

>>> try:
...     compose("errgraph")(
...        operation(name="screamer", needs=['a'], provides=["foo"])(scream)
...     )({'a': None})
... except ValueError as ex:
...     pprint(ex.graphkit_aid)
{'network':
  ...
 'operation': FunctionalOperation(name='screamer', needs=['a'], provides=['foo']),
 'operation_args': {'args': [None], 'kwargs': {}},
 'operation_fnouts': None,
 'operation_outs': None,
 'operation_results': None,
 'plan': ExecutionPlan(inputs=('a',), outputs=(), steps:
  +--FunctionalOperation(name='screamer', needs=['a'], provides=['foo'])),
 'solution': {'a': None}}


The following annotated attributes might have values on an exception ``ex``:

``ex.network``
   the innermost network owning the failed operation/function

``ex.plan``
   the innermost plan that executing when a operation crashed

``ex.operation``
   the innermost operation that failed

``ex.operation_args``
    either a 2-tuple ``(args, kwargs)`` or just the ``args`` fed to the operation

``ex.operation_fnouts``
    the names of the outputs the function was expected to return

``ex.operation_outs``
    the names eventually the graph needed from the operation
    (a subset of the above)

``ex.operation_results``
    the values dict, if any; it maybe a *zip* of the provides
    with the actual returned values of the function, ot the raw results.

.. note::
   The :ref:`plotting` capabilities, along with the above annotation of exceptions
   with the internal state of plan/operation often renders a debugger session
   unnecessary.  But since the state of the annotated values might be incomple,
   you may not always avoid one.


Execution internals
-------------------
.. automodule:: graphkit.network
   :noindex:
